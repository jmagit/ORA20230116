/*
   CREATE SEQUENCE  "HR"."EMPLEADOS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;

  CREATE TABLE "HR"."EMPLEADOS" 
   (	"ID_EMPLEADO" NUMBER(4,0) NOT NULL ENABLE, 
	"NOMBRE" VARCHAR2(50 BYTE) NOT NULL ENABLE, 
	"APELLIDOS" VARCHAR2(100 BYTE) NOT NULL ENABLE, 
	"SALARIO" NUMBER(7,2) DEFAULT 1080.00 NOT NULL ENABLE, 
	"ACTIVO" CHAR(1 BYTE) DEFAULT 'V', 
	"FINICIO" DATE DEFAULT SYSDATE NOT NULL ENABLE, 
	"FFIN" DATE, 
	"ID_DEPARTAMENTO" NUMBER(4,0) NOT NULL ENABLE, 
	"EMPLEADO" VARCHAR2(151 BYTE) GENERATED ALWAYS AS ("NOMBRE"||' '||"APELLIDOS") VIRTUAL , 
	 CONSTRAINT "EMPLEADOS_PK" PRIMARY KEY ("ID_EMPLEADO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "EMPLEADOS_UK_NOMBRE_APELLIDOS" UNIQUE ("NOMBRE", "APELLIDOS")
  USING INDEX (CREATE UNIQUE INDEX "HR"."EMPLEADOS_UK1" ON "HR"."EMPLEADOS" ("NOMBRE", "APELLIDOS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" )  ENABLE, 
	 CONSTRAINT "EMPLEADOS_CHK_NOMBRE_CORTO" CHECK (LENGTH(nombre) > 1) ENABLE, 
	 CONSTRAINT "EMPLEADOS_CHK_ACTIVO" CHECK (activo is null or activo in ('V', 'F')) ENABLE, 
	 CONSTRAINT "EMPLEADOS_CHK_FECHAS" CHECK (FFIN IS NULL OR FINICIO <=  FFIN) ENABLE, 
	 CONSTRAINT "EMPLEADOS_FK_DEPARTAMENTO" FOREIGN KEY ("ID_DEPARTAMENTO")
	  REFERENCES "HR"."DEPARTMENTS" ("DEPARTMENT_ID") ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

   COMMENT ON COLUMN "HR"."EMPLEADOS"."ACTIVO" IS '
';
   COMMENT ON COLUMN "HR"."EMPLEADOS"."FINICIO" IS '
';
   COMMENT ON TABLE "HR"."EMPLEADOS"  IS 'Demo del curso';

  CREATE INDEX "HR"."EMPLEADOS_INDEX_FECHAS" ON "HR"."EMPLEADOS" ("FINICIO" DESC, "FFIN" DESC) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_TRG" 
BEFORE INSERT ON EMPLEADOS 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID_EMPLEADO IS NULL THEN
      SELECT EMPLEADOS_SEQ.NEXTVAL INTO :NEW.ID_EMPLEADO FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_TRG" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_ANTES_ROW" 
BEFORE DELETE OR INSERT OR UPDATE ON HR.EMPLEADOS 
FOR EACH ROW 
BEGIN
    IF inserting THEN
        dbms_output.put_line('EMPLEADOS_ANTES_ROW INSERTING: ' || :new.EMPLEADO);
        :new.apellidos := upper(:new.apellidos);
    ELSIF updating THEN
        dbms_output.put_line('EMPLEADOS_ANTES_ROW UPDATING: ' || :new.id_empleado);
    ELSE
        if :old.activo = 'V' then
        RAISE_APPLICATION_ERROR(-20666, 'Invalid data: No se pueden borrar empleados activos.');
        end if;
        dbms_output.put_line('EMPLEADOS_ANTES_ROW DELETING: ' || :old.id_empleado);
    END IF;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_ANTES_ROW" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_COMPUESTO" 
FOR DELETE ON EMPLEADOS
COMPOUND TRIGGER
    cont PLS_INTEGER;
BEFORE STATEMENT IS
    BEGIN
      cont:=0;
    END BEFORE STATEMENT;
AFTER EACH ROW IS
    BEGIN
      cont:=cont+1;
    END AFTER EACH ROW;
AFTER STATEMENT IS
    BEGIN
      if cont > 1 then
        raise TOO_MANY_ROWS;
      end if;
    END AFTER STATEMENT;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_COMPUESTO" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_INTOCABLES" 
BEFORE DELETE OR UPDATE ON HR.EMPLEADOS 
FOR EACH ROW 
 WHEN (1 in (new.id_empleado, old.id_empleado)) BEGIN
    RAISE_APPLICATION_ERROR (-20069, 'Intocable');
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_INTOCABLES" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_ANTES_STMT" BEFORE
    DELETE OR INSERT OR UPDATE ON hr.empleados
BEGIN
    IF inserting THEN
        dbms_output.put_line('EMPLEADOS_ANTES_STMT INSERTING');
    ELSIF updating THEN
        dbms_output.put_line('EMPLEADOS_ANTES_STMT UPDATING');
    ELSE
        dbms_output.put_line('EMPLEADOS_ANTES_STMT DELETING');
    END IF;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_ANTES_STMT" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_DESPUES_STMT" 
AFTER
    DELETE OR INSERT OR UPDATE ON hr.empleados
BEGIN
    IF inserting THEN
        dbms_output.put_line('EMPLEADOS_DESPUES_STMT INSERTING');
    ELSIF updating THEN
        dbms_output.put_line('EMPLEADOS_DESPUES_STMT UPDATING');
    ELSE
        dbms_output.put_line('EMPLEADOS_DESPUES_STMT DELETING');
    END IF;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_DESPUES_STMT" ENABLE;

  CREATE OR REPLACE NONEDITIONABLE TRIGGER "HR"."EMPLEADOS_DESPUES_ROW" 
AFTER DELETE OR INSERT OR UPDATE ON HR.EMPLEADOS 
REFERENCING OLD AS original NEW as actual
FOR EACH ROW 
BEGIN
    IF inserting THEN
        dbms_output.put_line('EMPLEADOS_DESPUES_ROW INSERTING: ' || :actual.id_empleado);
    ELSIF updating THEN
        dbms_output.put_line('EMPLEADOS_DESPUES_ROW UPDATING: ' || :actual.id_empleado);
    ELSE
        dbms_output.put_line('EMPLEADOS_DESPUES_ROW DELETING: ' || :original.id_empleado);
    END IF;
END;
/
ALTER TRIGGER "HR"."EMPLEADOS_DESPUES_ROW" ENABLE;
*/

insert into empleados(nombre, apellidos, Salario, id_departamento)
select first_name, last_name, salary, department_id from employees where mod(employees.employee_id, 10) = 0;
select *  from empleados;

update empleados
set apellidos = apellidos
where empleados.id_empleado > 1 or 1 <> 1;

update empleados
set activo = 'V'
where id_departamento = 100;
-- commit;
delete from empleados 
where id_departamento = 100;

rollback;
